[{"title":"JavaScript语言精粹","url":"/bestjarvan/2021/12/30/notes/JavaScript语言精粹/","content":"1. [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)![image-20211227151339474](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112271513665.png)\n<!-- more -->\n2. 优先考虑使用.表示法，因为它更紧凑且可读性更好，但是如果你尝试检索一个不一定存在的值，则需使用['string']写法，它将返回一个`undefined`，若尝试从`undefined`的成员属性中取值，则会导致 TypeError 异常，这时可以通过`&&`运算符避免错误\n   ```javascript\n   const obj = {\n     name: 'zhangsan'\n   }\n   \n   obj.name // 'zhangsan'\n   obj['age'] // undefined\n   obj.hubby.name // throw 'TypeError'\n   obj.hubby && obj.hubby.name // undefiend\n   ```\n   \n3. `for in`语句可以遍历一个对象中的所有属性，该枚举过程将会列出所有的属性——包括函数和原型中的属性。所以通常可以使用`hasOwnProperty` 方法过滤。属性名的**出现顺序是不确定的**，如果你想要确保属性以特定顺序出现，最高的办法就是避免使用`for in`语句，而是创建一个数组，在其中以正确的顺序保函属性名。通过 for 而不是 for in，可以得到我们想要的属性，而不用担心可能发觉出原型链中的属性，并且我们按正确顺序取得了它们的值。\n\n   ```javascript\n   const obj = {.........}\n   const arr = [\n     'name',\n     'age',\n     'height',\n     'weight',\n     'hubby'\n   ]\n   arr.forEach(k => {\n   \tconsole.log(item + ': ' + obj[k])\n   })\n   ```\n\n4. 减少全局变量污染\n\n5. 闭包的好处是内部函数可以访问定义他们的外部函数的参数和变量(除了 this 和 arguments)，且内部函数拥有比外部函数更长的生命周期。\n\n6. 函数柯里化：1.参数复用；2.提前返回；3延迟计算/运行(bind就是个延迟执行的例子)\n\n7. 对象说明符：\n\n   ```javascript\n   // bad\n   const myObj = maker(a, b, c, d, e)\n   \n   // good\n   const myObj = maker({\n   \tfirst: a,\n     middle: b,\n   \tlast: c,\n     state: d,\n     city: e\n   })\n   // 现在多个参数可以按照任意顺序排列，如果maker函数接受参数使用默认值，那么一些参数也可以忽略调，并且代码也更容易阅读\n   ```\n   \n8. 伪类：当一个函数被创建时，新函数对象会被赋予一个`prototype`属性，他的值是一个包含`constructor`属性且属性值为该新函数的对象。`prototype`是存放继承特征的地方。当采用构造器调用模式，即用`new`前缀调用一个函数时，函数执行方式会被修改。构造器函数存在一个严重的危害，如果你在调用构造器函数时忘记加上`new`前缀，那么this将会绑定到全局对象上，造成不但没有扩充新对象，反而破坏了全局变量环境，所以构造器函数约定明明成首字母大写的形式(es6的class解决了这个问题，如果不用new调用，则会报错。es6的class可以看做是一个语法糖，他的绝大部分功能es5都可以做到，但是es6的class写法更加清晰、更像面对对象编程的语法)。\n\n9. 原型：一个新的对象可以继承一个旧对象的属性(`Object.creat(parentObj)`)。你可以通过构造一个有用的对象开始，接着构造更多的和那个对象类似的对象。这样可以完全避免把一个应用拆解成一系列嵌套抽象类的分类过程。\n\n10. 函数化：上面几种继承模式的一个弱点就是没法保护隐私(私有变量、私有函数)。如果对象的所有状态都是私有的，那么该对象就成为一个『防伪(tamper-proof)』对象。该对象的属性可以被替换或删除，但该对象的**完整性不会受到损害**。\n\n    ```javascript\n    const mammal = function (spec, my = {}) {\n      // my对象是一个为继承链中的构造器提供秘密共享的容器，my对象可以选择性使用\n      let _this\n      \n      _this = {}\n      // _this = new Object()\n      // _this = Object.creat({})\n    \n    \t// name和saying现在就是完全私有的，只能通过下面两个方法去访问它，无法从其他方式访问\n      _this.getName = function () {\n        return spec.name\n      }\n      _this.say = function () {\n    \t\treturn spec.saying || ''\n      }\n        \n      return _this\n    }\n    \n    const myMammal = mammal({ name: 'zhangsan' })\n    \n    // 创建cat继承他，我们的cat只需要关心自身差异\n    const cat = function (spec = 'meow') {\n      const _this = mammal(spec)\n      _this.xyz = function () {\n        return 'Hello World'\n      }\n      _this.getName = function () {\n        return 'aaaaaa==' + spec.name\n      }\n      return _this\n    }\n    \n    const myCat = cat({name: 'lisi'})\n    ```\n\n11. 正则尾部符号意义: g(global)/i(ignoreCase)/m(multiline)![image-20211229142706807](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112291427083.png)\n\n12. 用正则表达式字面量创建RegExp对象共享**同一个单利**：\n\n    ```javascript\n    // 字面量\n    function test () {\n    \treturn /a/gi\n    }\n    \n    const x = test()\n    const y = test()\n    \n    x.lastIndex = 10\n    console.log(y.lastIndex) // 10\n    \n    // new\n    function reg () {\n    \treturn new RegExp(a, 'gi')\n    }\n    \n    const x = reg()\n    const y = reg()\n    \n    x.lastIndex = 8\n    console.log(y.lastIndex) // 0\n    ```\n\n13. 除了控制字符和特殊字符外，所有的字符都会被按照字面处理，下列字符如果需要按照字面去匹配，那么必须要用一个`\\`前缀来进行转义。\n\n    ```javascript\n    \\ / [ ] ( ) { } ? + * | . ^ $\n    ```\n\n14. 正则表达式分组：\n\n    1. 捕获型(/([a-z])/)：任何匹配这个分组的字符都会被捕获。每个捕获型分组都被指定了一个数字。在正则表达式中第一个捕获(的分组是1，第二个捕获(的分组是2。(\\$1....$x)\n    2. 非捕获型(/(?:a)/)：非捕获型分组仅做简单的匹配，并不会捕获所匹配的文本。这会带来**微弱的性能优势**。非捕获型分组不会干扰捕获型分组的编号。\n    3. 向前正向匹配(/(?=a)/)：它类似于非捕获型分组，但在这个组匹配后，文本会倒回到它开始的地方，实际上并不会匹配到任何东西。这不是一个好特性。\n    4. 向前负向匹配(/(?!a)/)：它类似于向前正向匹配分组，但只有当它匹配失败时它才回继续向前进行匹配。这不是一个好特性\n\n    ```javascript\n    \"abcabc\".match(/(a)(b)(c)/) // [\"abc\", \"a\", \"b\", \"c\"]\n    \"abcabc\".match(/(?:a)(b)(c)/) // [\"abc\", \"b\", \"c\"]\n    \n    '<div>'.match(/<(?=br>)/) // null\n    '<br>'.match(/<(?=br>)/) // [\"<\"]\n    \n    '<div>'.match(/<(?!br>)/) // [\"<\"]\n    '<br>'.match(/<(?!br>)/) // null\n    ```\n\n15. `regexp.exec()`是正则表达式最强大(也是最慢)的方法。如果它成功匹配`regexp`和字符串`string`，它会返回一个数组。数组下标0的元素将包含正则表达式regexp匹配的子字符串。下标1的元素是分组1捕获的文本，2的元素是分组2捕获的文本，以此类推。如果匹配失败，它会放回`null`。如果regexp带有一个g标识，`regexp.lastIndex`会被设置为该匹配后第一个字符的位置，不成功则会重置为0。\n\n16. `regexp.test()`是正则表达式最简单(也是最快)的方法。如果它匹配成功则会返回`true`，否则返回`false`。不要对这个方法使用g标识。\n\n17. 统一的代码风格....\n\n18. 毒瘤：\n\n    1. 全局变量\n    2. 自动插入分号\n\n19. 糟粕：\n\n    1. ==，隐式转换：\n       1. 对象和布尔值比较时，会先转换为字符串，在转换为数字\n       2. 对象和字符串比较时，对象转换为字符串，然后两者进行比较\n       3. 对象和数字比较时，对象转化为字符串,然后转换为数字，再和数字进行比较\n       4. 字符串和数字比较时，字符串转换为数字\n       5. 字符串和布尔值进行比较时，二者全部转换成数值再比较\n       6. 布尔值和数字进行比较时，布尔转换为数字\n\n    ```javascript\n    '' == 0 // true\n    [1,2,3] == '1,2,3' // true\n    '0' == false // true\n    [] == false // true\n    true == 1 // true\n    ```\n\n    1. with: js提供了with语句，本意是想用它来快捷的访问对象属性，不幸的是，他的结果有时不可预料\n    2. eval: eval传递一个字符串给js编译器，并执行其结果。使用eval会导致代码更加难以阅读，且导致性能显著降低，因为它需要运行编译器。eval函数减弱了程序的安全性，因为他给求值的文本太多权利，而且就像with语句执行方式一样，他降低了语言的性能\n    3. continue: 重构移除continue后，性能会得到改善\n    4. 缺少块的语句：貌似在做一件事，实际确实另一件事的程序是非常难理解清楚的。\n\n    ```javascript\n    if (a)\n      t = 1\n    \tfn()\n    \n    // 它看起来像是要这样:\n    if (a) {\n    \tt = 1\n      fn()\n    }\n    \n    // 实际上本意是\n    if (a) {\n    \tt = 1\n    }\n    fn()\n    ```\n\n    5. 位运算符：在java里，位运算符处理的是整数，ja没有整型，只有双精度浮点数。因此，位操作符把它们的数字运算数先转换成整数，接着执行运算，最后再换回去。再大多数语言中，这些位运算符接近于硬件处理，所以非常快，而js执行环境一般接触不到硬件，所以非常慢。\n\n    ```javascript\n    &\t\t\tand 按位与\n    |\t\t\tor  按位或\n    ^\t\t\txor 按位异或\n    ~\t\t\tnot 按位非\n    >>\t\t带符号右位移\n    >>>\t\t无符号又位移(用0补足)\n    <<\t\t左位移\n    ```\n","categories":["notes"]},{"title":"macOS 12 升级xcode 13后无法打开iOS11.4Simulator解决方法","url":"/bestjarvan/2021/11/19/notes/macOS12升级xcode13后无法打开iOS11.4Simulator解决方法/","content":">macOS升级到12 macOS Monterey后，xcode(version 12)提示无法使用，需要升级，升级前还能打开iOS11.4的Simulator，升级后(xcode 13)提示不支持低版本iOS，最低支持iOS12版本，但是项目中又需要用到低版本的系统。\n<!-- more -->\n1. 首先确保xcode有安装iOS11.4的Simulator，若没有则需要`Xcode > Preferences > Components`下载需要的Simulator![模拟器版本](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171407668.png)\n2. 下载完毕后，打开finder，commond+shift+g快速前往Simulator安装目录`/Library/Developer/CoreSimulator/Profiles/Runtimes`，选中对应的模拟器版本右键显示包内容，找到`Info.plist`，拷贝到桌面一份![Info.plist](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171407086.png)\n3. 双击打开桌面的`Info.plist`，默认使用Xcode打开，找到Bundle identifier，修改值，在最后面加一个-1，使版本检查函数找不到对应的bundle name跳过检查，修改后复制桌面的文件回到原来的位置覆盖粘贴(此处可能需要验证权限)![iOS](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171407865.png)\n4. Terminal中输入`open -a Simulator`打开模拟器，选择`File > New Simulator`，点击Create就可以创建低版本Simulator了，如果没有自动打开Simulator，则手动选择`File > Open Simulator`找到iOS 11.4去打开![Simulator](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171407106.png)\n![iOS 11.4](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171408620.png)\n\n参考：https://hiraku.tw/2021/04/6428/","categories":["notes"]},{"title":"typec快速分离线","url":"/bestjarvan/2021/10/15/notes/typec快速分离线/","content":"#### 材料：\n\n* 航空插头\n* typec数据线\n* 电烙铁，焊锡、助焊剂等\n<!-- more -->\n#### 焊接要点：\n\n* 胆大心细，温度合适\n* 注意焊头不要长期高温空置，长期不用就调低温度，短期不用就注意及时挂锡\n* 要焊接的地方提前上锡，方便焊接\n* 焊接前可以点下松香，去掉氧化层再上锡\n\n#### 步骤：\n\n1. 简单粗暴，直接干断，电线芯剥一点露出铜线头，方便焊接\n![断点自己喜欢就好](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171409142.png)\n2. 铜线镀锡，防止焊接时候散开\n![镀锡](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171409132.png)\n3. 焊接两个点，记住焊接的点位，航插上有个防呆扣，方便记忆，线序焊错差上是不能用的\n![固定](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171409503.png)\n4. 点位焊接完毕，检查是否有虚焊\n![检查固定](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171409468.png)\n5. 焊接母头，操作跟上面一直，一定要确定线序对齐，一定要确定线序对齐，一定要确定线序对齐，保鲜膜绕线大法（线材质太硬，或者我操作有问题，失败了XD）\n![绕线](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171410189.png)\n5. 上机检查，查看是否能用\n6. 检查完后开始注胶，灌注704胶或者热熔枪固定（热熔枪凝固太快，选择了704胶灌注）\n![注胶](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171410506.png)\n7. 等待凝固后就可以正常用啦\n![成品](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171410555.png)\n![成品](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171410518.png)\n\n#### 撸键盘\n键盘就比较简单了，找一把带主控的pcb板子，直接插轴焊接轴脚，焊接键盘是个耐力活儿，不难但是多\n![pcb](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171410985.jpeg)\n\n![这把键盘用的ttc青轴，声音清脆，手感不错](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171410300.jpeg)","categories":["notes"]},{"title":"xbb-utils开发规范","url":"/bestjarvan/2021/08/15/notes/xbb-utils开发规范/","content":"为什么选择开发utils包？\n\n- 方便代码的快速维护\n- 方便一套代码部署多个项目以及新项目的快速启动\n- 为后期需求踩坑\n<!-- more -->\n为什么选择ts？\n\n- 有更加安全的静态类型检查，而静态类型检查更有利于构建大型项目\n- 增加了代码可读性\n- 更有好的IDE代码提示\n\n### 版本规范\n\n主版本号.子版本号.修正版本号\n\n修复bug：修正版本号+1\n\n新增方法：子版本号+1，修正版本号复位为 0\n\n整体影响：重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1，其余版本号复位为0\n\n|版本号|备注|\n|---|---|\n|v0.0.1|基础搭建|\n|v0.1.0|新增vue2.x调试页面|\n|v0.1.1|修复bug，完善单测|\n|v0.1.2|修复bug，维护更新|\n|v1.1.0|优化math方法，新增thumbnail, formatToNumber, dealNumber, getGuid方法|\n\n\n\n### 项目结构\n\n每个文件夹都有各自的职责，项目配置文件单独列出来方便修改配置。核心模块也就只有`src`文件，其余都是辅助。\n\n```JavaScript\n.\n├── LICENSE\n├── README.md\n├── babel.config.js\n├── coverage // 单测结果\n│   └── lcov-report\n│       └── index.html // 单测结果页面入口\n├── docs // typedoc生成的文档\n│   ├── assets\n│   ├── globals.html\n│   ├── index.html\n│   └── interfaces\n├── gulpfile.js // gulp+rollup配置文件\n├── package.json\n├── src // 代码模块\n│   ├── core // 核心代码块\n│   │   ├── env.ts\n│   │   └── **.ts\n│   ├── index.ts // 入口文件\n│   ├── tools\n│   │   └── index.ts // 工具\n│   └── types // 声明文件\n│       └── index.ts // interface\n├── tests // 单元测试\n│   └── unit // 核心测试模块\n├── home // vue调试页面\n│   └── ** // 调试\n├── vue.config.js // vue项目配置(调试用)\n├── jest.config.js // jest单测配置\n├── tsconfig.json // ts配置\n├── tslint.json // tslint配置\n├── .prettierrc // prettier配置\n├── .lintstagedrc // lintstage配置\n└── typedoc.json // typedoc配置\n\n```\n\n\n### src\n\n1. 所有功能模块需要开发到`src/core/**`下，此文件为核心代码块；\n2. 具体功能目前划分了几大类别`math` `url` `is` `method` `verify`...等等，后期按需添加；\n3. `core`下的方法都需要导出，且需要添加注释，注释参考下图(图1)，此描述不生成文档，故可以写的更加详细；\n4. `core/is.ts`为类型判断文件，推荐大家项目中需要进行类型判断时候使用此文件，而不是书写新的判断代码。\n5. `types`文件夹放interface接口声明，`interface`有几个大类对应`core`下的文件命(图2)，作为开发中的代码提示文案，interface的备注需要书写的清晰，传入的参数以及返回的参数类型一定要正确，文案也要相对简练。\n6. 类型超过3个(包含3个)推荐使用类型别名，例如：\n\t```TypeScript\n\t// bad\n\texport function checkType(val: Date | string | number): Date {\n\t  // TODO...\n\t}\n\t\n\t// good\n\ttype dateType = Date | string | number\n\texport function checkType(val: dateType): Date {\n\t  // TODO...\n\t}\n\t```\n\t\n\n备注：因为使用了自动文档生成工具，所以为了避免文档输出混乱，备注需要统一的规则。除`types`文件下的方法，其余的都需要添加`@ignore`阻止文档的自动生成，\n\n![图1](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221047229.png)\n\n![图2](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221047515.png)\n\n### 单测\n\n1. `unit/index.spec.ts`文件用来测试实例是否挂载了对应的方法(`/src/core/**.ts`)，每次在`core`下新增方法后，都需要到这个文件下的对应单测模块中添加测试实例，用于确保实例有此方法，相当于双重保险；\n2. `unit/core/**.spec.ts`为对应的`core`下的核心单测文件，每个单测方法都有一个大的`describe`包裹数个`it`，方便单测报错时，定位具体哪个文件下的哪个方法报错，错误日志会输出`describe`和`it`的描述文案；\n\t![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221047549.png)\n3. 单测文件需要把要测试的代码中的每一个分支，每一行代码，每一个判断都要覆盖，需要完成方法覆盖100%，分支覆盖98%，行数覆盖100%的条件，推荐全部100%；\n\t![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221047925.png)\n4. 单测结果可以在控制台或者`coverage/lcov-report/index.html`查看详情。\n\t![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221047418.png)\n\t- 第一行10x 代表当前行走了10次\n\t- 黄色img[0]表示单测这行代码没有覆盖到\n\t- `if`前的E标识，说明此`if`判断的`else`条件没有覆盖\n\t- 红色则表示整行(大段代码)没有覆盖到，考虑是否漏写该方法的单测\n\n### 调试\n\n本项目为了方便调试，已集成vue2.x，可以通过`npm run serve`启动vue项目。\n\nvue项目目录为`home/*`。\n\n### 使用\n\n需要用到的项目，使用`npm i -S xbb-utils`来安装最新版本，之后再需要用到的页面`import xbb from 'xbb-utils'`\n\n![代码提示](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221047096.png)\n\n### 功能开发\n\n1. 首先需要基于远端master拉取最新代码分支\n2. 新建开发分支，一般为feature/开发分支名的格式`git checkout -b feature/xxxxx`\n3. 推送开发分支到远端并追踪关系`git push --set-upstream origin feature/xxxxx`\n4. enjoy your coding...\n\nps: 如果有好的点子但是没有时间开发，可以再gitlab提交issues\n\n### 开发完成\n\n1. 开发完成后需要再跑一遍单测，确保通过率为100%\n2. 检查无误，没有问题之后，去gitlab提交MR(merge request)\n3. 待管理员审核无误后发布，会在群里通知最新版本号，及时更新到最近版本即可\n\n\n\n","categories":["notes"]},{"title":"input超过10的20次方显示科学记数法的解决方案","url":"/bestjarvan/2020/11/13/js/input超过10的20次方显示科学记数法的解决方案/","content":">项目中用到input type=\"number\" 输入框如果数值超过了10的20次方会显示成10exxx或者10e+xxx \n>解决方案：\n>1.说服产品，一般情况下不会存在大于10的20次方或者小于是的负10次方的值\n>2.转换成字符串形式展示\n\n网上找的不是这个不匹配就是那个结果不对，那干脆自己写个好了\n<!-- more -->\n```javascript\nfunction ScientificNumber (num) {\n    if (!num) return num\n    const str = num.toString()\n    const reg = /^(\\d+)(\\.\\d+)?(e)([+]?\\d+)$/\n    const reg2 = /^(\\d+)(\\.\\d+)?(e)([-]?\\d+)$/\n    let arr\n    let len\n    let zero = ''\n    if (reg.test(str)) {\n      arr = reg.exec(str)\n      // 保留小数位数\n      const arr2 = arr[2] ? arr[2].replace('.', '') : ''\n      // 此处减去arr2的长度为了兼容有小数情况\n      len = Math.abs(arr[4]) - (arr2.length || 0)\n      for (var i = 0; i < len; i++) {\n        zero += '0'\n      }\n      return arr[1] + arr2 + zero\n    } else if (reg2.test(str)) {\n      arr = reg2.exec(str)\n      len = Math.abs(arr[4]) - 1\n      const arr2 = arr[2] ? arr[2].replace('.', '') : ''\n      for (let index = 0; index < len; index++) {\n        zero += '0'\n      }\n      return '0.' + zero + arr[1] + arr2\n    } else {\n      return num\n    }\n  }\n```\n\n![测试结果](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171510537.png)","categories":["js"]},{"title":"回调与异步编程","url":"/bestjarvan/2020/08/07/js/回调与异步编程/","content":"\n#### 一、回调函数的使用场景\n\n1. 异步编程。\n2. 事件监听、处理。\n3. setTimeout、setInterval方法。\n4. 通用功能，简化逻辑。\n<!-- more -->\n#### 二、异步编程的4种方法\n\n1. 回调函数。\n2. 事件监听。\n3. 发布订阅。\n4. Promise对象。\n\n\n\n回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段代码。\n\n```javascript\nfn1(fn2)\nfunction fn1 () {\n  // to do...\n  fn2()\n}\n\nfunction fn2 () {\n  // to do...\n}\n```\n\n\n\n说到异步编程，那么就有必要了解js的事件循环机制Event Loop\n\n![image.png](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171427632.png)\n\n#### 1. 栈和队列\n\n![image.png](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171427417.png)\n\n栈：    后进先出（LIFO-last in first out）:最后插入的元素最先出来。\n\n队列：先进先出（FIFO-first in first out）:最先插入的元素最先出来。\n\n#### 2. 宏任务和微任务(浏览器)\n\n宏队列，macrotask。一些异步任务的回调会依次进入macro task queue，等待后续被调用：\n\n- setTimeout和setInterval\n- requestAnimationFrame\n- I/O\n- UI rendering\n\n微队列，microtask。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用：\n\n- Promise.then\n- Object.observe\n- MutationObserver\n\n执行顺序：\n\n1. 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等），遇到异步代码根据上述任务划分到对应队列中；\n2. 全局Script代码执行完毕后，调用栈Stack会清空；\n3. 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\n4. 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。（即清空微任务队列，注意：如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行）\n5. microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n6. 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n7. 执行完毕后，调用栈Stack为空；\n8. 重复第3-7个步骤；\n9. ...\n\n简单来说，执行主线程同步代码遇到异步任务挂起划分到对应任务队列，主线程同步代码执行完毕后，清空微任务队列，此时微任务清空，执行栈清空，开始执行宏任务，执行完一个宏任务后查看微任务队列并执行清空，之后继续执行宏任务依次循环。\n\n概念性的东西就这么多，来看几个示例代码，测试一下你是否掌握了:\n\n```javascript\nconsole.log(1)\n\nsetTimeout(() => {\n  console.log(2)\n  Promise.resolve().then(() => {\n    console.log(3)\n  })\n})\n\nnew Promise((resolve, reject) => {\n  console.log(4)\n  resolve(5)\n}).then(data => {\n  console.log(data)\n  return 6\n}).then(data => {\n  console.log(data)\n})\n\nsetTimeout(() => {\n  console.log(7)\n  Promise.resolve().then(() => {\n    console.log(8)\n  })\n})\n\nconsole.log(9)\n```\n\n","categories":["js"]},{"title":"前端数据存储之IndexedDB","url":"/bestjarvan/2020/08/06/js/前端数据存储之IndexedDB/","content":"\n##### 一、关于前端数据存储常用的几个方案\n\n1. Cookie\n2. Web Storage\n3. IndexDB\n<!-- more -->\n##### 二、cookie和storage差异对比\n\n|   特点   |                      Cookie                      |                         Web Storage                          |                           IndexDB                            |\n| :------: | :----------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n| 生命周期 |           可设置过期时间或跟随当前页面           |      localStorage: 永久有效sessionStorage: 跟随当前页面      |            永久有效，除非手动清除，同localStorage            |\n| 数据大小 |                        4k                        |                            一般5m                            |                    取决于硬盘的大小的50%                     |\n|   局限   | 每次请求都会携带到header中，使请求数据无意义增大 | 对于Object类型数据必须json序列化才能储存，且是同步操作，大数据操作会阻塞进程 | 若磁盘满，最近最少使用的源将首先被删除，然后是下一个，直到浏览器不再超过限制。 |\n\n##### 三、IndexDB特点\n\n1. **键值对储存。**IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以\"键值对\"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n2. **异步。** IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，锁死用户操作。\n3. **支持事务。** IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况，操作数据更安全。\n4. **支持索引。** IndexedDB 数据表可以建立索引，索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。\n5. **同源限制。** IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n6. **储存空间大。** IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，大小一般是硬盘大小的50%，超过就会触发源回收。\n7. **支持二进制储存。** IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。\n\n##### 四、IndexDB用法\n\nIndexDB已经被封装抽离成一个个的API，所以使用时可以直接调用浏览器API。\n\n新建数据库，open方法接收两个参数 一个是数据库名字 第二个是版本号，整数，默认为1或当前版本\n\n若没有对应库名的数据库则会进行新建数据库操作\n\nopen方法返回一个IDBRequest对象，对象通过**error、success、upgradeneeded**，处理打开数据库的操作结果\n\n```javascript\nlet request = window.indexedDB.open(databaseName, version)\nlet db\n\nrequest.onerror = (event) => {\n  console.log('数据库打开报错', event)\n}\n\nrequest.onsuccess = () => {\n  db = request.result\n  console.log('数据库打开成功', db)\n}\n\nrequest.onupgradeneeded = ({ target: { result } }) => {\n  // changing objectStore data is done here, as opposed to a transaction enum:\n  db = result\n  console.log('数据库升级', db)\n}\n```\n\n![1](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/MeYVOLxGWMYAOpz2/img/66cc1241-764f-49f5-ba5c-f03599eb3a3e.png)\n\n现在，我们新建了一个名字叫做demoBase的数据库，那么光有数据库是不够的，我们还需要新建对象仓库(object store)类似于MySQL的表\n\n> 要创建一个对象仓库必须在upgradeneeded事件中，而upgradeneeded事件只会在版本号更新的时候触发，这是因为IndexedDB API中不允许数据库中的数据仓库在同一版本中发送变化\n\n```javascript\n// changing objectStore data is done here, as opposed to a transaction enum:\nrequest.onupgradeneeded = function ({ target: { result } }) {\n  console.log('数据库升级', result)\n  db = result\n  let objStore\n  // Node.contains()返回的是一个boolean，来表示传入的节点是否为该节点的后代节点。\n  // 判断是否有person对象仓库 若没有则新建一个对象仓库(即新建表)\n  if (!db.objectStoreNames.contains('person')) {\n    /**\n     * 新建person表 主键(key)是默认建立的索引，比如下面我们使用id做为主键\n     * @param name: string\n     * @param optionalParameters?: IDBIndexParameters\n     * keyPath\n     * autoIncrement\n    */\n     objStore = db.createObjectStore('person', { keyPath: 'id' })\n    /**\n     * 创建索引 用于快速检索\n     * @param name: string\n     * @param keyPath: string | string[]\n     * @param optionalParameters?: IDBIndexParameters\n    */\n    objStore.createIndex('nameIndex', 'name', { unique: false })\n  }\n}\n```\n\n现在，数据库和表我们都有了，那么下一步就是操作表，也就是增、删、改、查数据，我们需要通过事务来操作\n\n>一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含了两个以上目的\n>1、为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍然保持一致性的方法\n>2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作相互干扰\n\n1. 增\n\n   新增数据，首先需要新建一个事务，新建时必须指定表格名称和操作模式（\"只读\"或\"读写\"）\n\n   ```javascript\n   function add() {\n     let content = db.transaction(['person'], 'readwrite')\n     \t.objectStore('person')\n     \t.add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });\n   \n     content.onsuccess = (event) => {\n       console.log('数据写入成功')\n     }\n   \n     content.onerror = (event) => {\n       console.log('数据写入失败')\n     }\n   }\n   ```\n\n   此时一条数据已经新增成功我们可以打开Chrome DevTools，关于数据存储可以打开Application再Storage中找到IndexDB\n\n2. 删\n\n   ```javascript\n   function remove() {\n     const request = db.transaction(['person'], 'readwrite')\n       .objectStore('person')\n       .delete(1)\n   \n     request.onsuccess = (event) => {\n       console.log('数据删除成功')\n     }\n   \n     request.onerror = (event) => {\n       console.log('数据删除失败')\n     }\n   }\n   ```\n\n   \n\n3. 改\n\n   ```javascript\n   function update () {\n     const request = db.transaction(['person'], 'readwrite')\n       .objectStore('person')\n       .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' })\n   \n     request.onsuccess = (event) => {\n       console.log('数据更新成功')\n     }\n   \n     request.onerror = (event) => {\n       console.log('数据更新失败')\n     }\n   }\n   ```\n\n   \n\n4. 查\n\n   ```javascript\n   function search () {\n     // 新建查询事务\n     const request = db.transaction(['person'])\n       .objectStore('person')\n   \t\t// 查询主键是1的  \n       .get(1)\n     \t// 通过索引查\n     \t// .index('name')\n       // .get('李四')\n   \n     request.onsuccess = (event) => {\n       if (request.result) {\n         console.log('data===', request.result)\n       } else {\n         console.log('未获得数据记录')\n       }\n     }\n     \n     request.onerror = (event) => {\n       console.log('事务失败')\n     }\n   }\n   ```\n\n##### 五、简单封装使用\n\n```javascript\nclass IndexDBDemo {\n  db = null\n\n  constructor(name, storeOpt = {}, key = null, indexOpt = {}) {\n    if (!this.db) {\n      this.init(name, storeOpt, key, indexOpt)\n    }\n    return this.db\n  }\n\n\t// 初始化\n  init (name, storeOpt = {}, key = null, indexOpt = {}) {\n    console.log('init')\n    const request = indexedDB.open(name)\n\n    return new Promise((res, reject) => {\n      request.onsuccess = () => {\n        this.db = request.result\n      }\n  \n      request.onupgradeneeded = function ({ target: { result } }) {\n        this.db = result\n        if (!this.db.objectStoreNames.contains(name)) {\n          const req = this.db.createObjectStore(name, storeOpt)\n          if (key) {\n            req.createIndex(key, key, indexOpt)\n          }\n        }\n        res()\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n\n  add (name, data) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name], 'readwrite')\n        .objectStore(name)\n        .add(data)\n\n      request.onsuccess = (event) => {\n        result(event)\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n\n  remove(name, key) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name], 'readwrite')\n        .objectStore(name)\n        .delete(key)\n\n      request.onsuccess = (event) => {\n        result(event)\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n\n  update (name, data) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name], 'readwrite')\n        .objectStore(name)\n        .put(data)\n\n      request.onsuccess = (event) => {\n        result(event)\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n\n  search (name, index) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name])\n        .objectStore(name)\n        .get(index)\n\n      request.onsuccess = (event) => {\n        if (request.result) {\n          result(request.result)\n        } else {\n          console.log('no data')\n          reject()\n        }\n      }\n\n      request.onerror = (error) => {\n        console.log('事务失败')\n        reject(error)\n      }\n    })\n  }\n\n  searchIndex(name, key, index) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name])\n        .objectStore(name)\n        .index(key)\n        .get(index)\n\n      request.onsuccess = (event) => {\n        if (request.result) {\n          result(request.result)\n        } else {\n          console.log('no data')\n          reject()\n        }\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n}\n\n// 使用\nthis.db = new IndexDBDemo(name, { keyPath: 'id', autoIncrement: true }, 'name', { unique: false })\nthis.db.add(name, obj).then().catch()\nthis.db.remove(name, key).then().catch()\nthis.db.update(name, obj).then().catch()\nthis.db.search(name, key).then().catch()\nthis.db.searchIndex(name, '索引', '索引值').then().catch()\n\n```\n\n\n\n##### 六、浏览器兼容\n\n更多高级用法参考[Web API](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API#Browser_compatibility) \n\n功能再强大，不兼容也不行，下面是浏览器兼容图，数据来源 [can i use](https://caniuse.com/#search=IndexDB)\n\n![浏览器兼容情况](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221109134.png)","categories":["js"]},{"title":"Typescript+verdaccio+pm2构建私有工具包","url":"/bestjarvan/2020/04/14/npm/Typescript+verdaccio/","content":"> 项目中经常会用到某些方法，比如格式化时间戳，比如判断环境等等，笔者最初是把这些方法抽离出来写成公共方法，但由于后期项目扩展每次都要复制这个工具文件很是麻烦且效率低下，发布npm包正好解决了这个痛点，正好借此机会重构成ts文件并发布npm包。\n\n<!-- more -->\n本文只简要介绍下整个流程，具体参考[utils项目](https://gitee.com/bestjarvan/utils/tree/master)\n\n### 简要\n\n- 工具\n- 项目架构\n- 初始化\n- 单元测试\n- 文档输出\n- 打包\n- 发布\n\n### 工具\n\n- [typescript](https://www.tslang.cn/)\n- [typedoc](http://typedoc.org/)\n- [rollup](https://www.rollupjs.com/) + [gulp](https://www.gulpjs.com.cn/)\n- [jest](https://jestjs.io/)\n- [pm2](https://pm2.keymetrics.io/) + [verdaccio](https://verdaccio.org/)\n\n### 项目架构\n\n```纯文本\n.\n├── LICENSE\n├── README.md\n├── docs // typedoc生成的文档\n│   ├── assets\n│   ├── globals.html\n│   ├── index.html\n│   └── interfaces\n├── gulpfile.js // gulp+rollup配置文件\n├── package.json\n├── src // 代码模块\n│   ├── core // 核心代码块\n│   │   ├── env.ts\n│   │   └── ***.ts\n│   ├── index.ts // 入口文件\n│   ├── tools\n│   │   └── index.ts\n│   └── types // 声明文件\n│       └── index.ts\n├── test // 单元测试\n│   ├── core // 核心代码单元测试\n│   │   ├── env.spec.ts\n│   │   └── ***.spec.ts\n│   └── index.spec.ts\n├── tsconfig.json // ts配置\n├── tslint.json // tslint配置\n├── .prettierrc // prettier配置\n├── .lintstagedrc // lintstage配置\n└── typedoc.json // typedoc配置\n```\n\n\n### 初始化\n\n1. `npm init`初始化项目\n2. 安装依赖`npm i -D gulp del typescript`\n3. 安装[rollup](https://www.rollupjs.com/guide/tools#gulp)依赖`npm i -D rollup rollup-plugin-node-resolve rollup-plugin-commonjs rollup-plugin-typescript2 rollup-plugin-uglify rollup-plugin-sourcemaps rollup-plugin-json`\n4. 安装辅助插件`npm i -D typedoc jest @types/jest ts-jest`\n5. 在项目中新建一个src文件，编写公共文件\n6. 需要一个types文件夹存放声明文件(用于代码提示)\n7. 所有文件都需要通过src/index.ts 对外抛出\n\n```纯文本\n// gulpfile.js\nconst gulp = require('gulp')\nconst del = require('del')\nconst rollup = require('rollup')\nconst json = require('rollup-plugin-json')\nconst commonjs = require('rollup-plugin-commonjs')\nconst resolve = require('rollup-plugin-node-resolve')\nconst sourceMaps = require('rollup-plugin-sourcemaps')\nconst typescript = require('rollup-plugin-typescript2')\nconst uglify = require('rollup-plugin-uglify').uglify\nconst pkg = require('./package.json')\n\n// 删除打包后的文件 目的为了每次打包出来的结果更干净，避免某些文件没被删除等原因抛错\nfunction task_clean (done) {\n  del.sync('dist')\n  del.sync('docs')\n  done()\n}\n\nasync function task_ts () {\n  const bundle = await rollup.rollup({\n    input: 'src/index.ts',\n    plugins: [\n      json(),\n      // Compile TypeScript files\n      typescript({ useTsconfigDeclarationDir: true }),\n      // Allow bundling cjs modules (unlike webpack, rollup doesn't understand cjs)\n      commonjs(),\n      // Allow node_modules resolution, so you can use 'external' to control\n      // which external modules to include in the bundle\n      // https://github.com/rollup/rollup-plugin-node-resolve#usage\n      resolve(),\n  \n      // Resolve source maps to the original source\n      sourceMaps(),\n      uglify(),\n    ]\n  });\n\n  await bundle.write({\n    file: pkg.main,\n    format: 'umd',\n    name: pkg.name,\n    sourcemap: false\n  })\n}\n\ngulp.task('default',\n  gulp.parallel(\n    task_clean,\n    task_ts\n  )\n)\n```\n\n\n### 单元测试\n\n配置代码通过率最低标准\n例如我配置的 必须全部分支、方法、代码行数通过率达到90%才算测试通过\n\n```纯文本\n  coverageThreshold: {\n    global: {\n      branches: 90,\n      functions: 90,\n      lines: 90,\n      statements: -5\n    }\n  }\n```\n\n\n`jest --coverage // 生成测试覆盖率`<br />\n\n![测试结果](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171509157.png)\n\n\n### 文档输出\n\n1. 配置typedoc\n\n```纯文本\n// package.json  scripts片段\n{\n  \"build\": \"npm run lint && gulp && typedoc\",\n}\n// tslint\n// gulp 会自动识别根目录下gulpfile.js配置文件\n// typedoc 自动识别根目录下typedoc.json配置文件\n// 参考项目结构\n```\n\n\n1. build后就可以提交到git服务器，比如我用的gitee使用gitee pages（静态页面托管，免去自己申请域名、服务器、虚拟主机等，github有github pages等）\n2. gitee pages简单的设置下入口文件(比如docs/index.html)就会生产对应的在线文档链接\n3. 使用 git hooks搭配 lint-staged 在提交时先去格式化暂存区代码，保持代码干净之后push代码\n\n![gitee pages](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171509630.png)\n\n\n### 打包\n\n使用rollup配合gulp打包编译\n\n1. gulp配置中使用del删除dist文件，避免其他意外问题\n2. 使用rollup编译ts文件\n3. 编译后会保留声明文件，在package.json中typings字段写入汇总的声明文件地址，用于代码提示\n4. 丑化压缩js文件\n5. 输出到package.json定义的入口文件dist/index.js\n\n### 发布\n\n一、发布到npm市场\n\n1. 需要先在terminal登录npm\n2. 手动修改package.json的version(后期脚本自动更新)，npm publish，成功后会得到一个版本信息\n\n```纯文本\n+ @jarvannnn/utils@0.0.1\n```\n\n\n1. npm i --save @jarvannnn/utils 就可以项目中使用了\n\n二、使用verdaccio搭建npm私服，并使用pm2守护进程\n\n1. `npm install -g verdaccio pm2`全局安装verdaccio以及pm2[^pm2]\n2. terminal直接输入verdaccio 即可立即运行，默认抛出端口为4873，我们可以使用`pm2 start verdaccio`指令使其运行到后台\n3. 现在我们可以通过`localhost:4873`访问npm私服^localhost\n4. 发布到verdaccio平台 首先需要在terminal中输入`npm adduser --registry http://localhost:4873`注册用户，输入用户名、密码、邮箱等信息注册\n5. `npm publish --registry http://localhost:4873` 发布代码包\n\ntips: 如果跟我一样不喜欢每次发布都要输入--registry，那么可以借助nrm[^nrm]镜像源管理工具来管理本地源\n\n### 项目中使用\n\n![代码提示](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171509895.png)\n\n![代码提示](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171509773.png)\n\n[^pm2]:  * `pm2 start verdaccio` 启动verdaccio<br />* `pm2 stop verdaccio(all) ` 停掉verdaccio(或全部)<br />* `pm2 delete verdaccio` 删除verdaccio<br />* `pm2 show verdaccio` 显示verdaccio运行日志\n\n[^nrm]: * `nrm add mynpm http://localhost:4873` 添加本地源<br />* `nrm use mynpm` 切换本地源<br />* `nrm ls` 查看本地所有源\n\n","categories":["npm"]},{"title":"npm私有平台发布流程","url":"/bestjarvan/2019/12/15/npm/npm私有平台发布流程/","content":"### 一、源管理工具nrm\n\n1. 全局安装`npm i -g nrm`\n2. 添加逍邦源`nrm add xbb http://npm.xbongbong.com.cn/`\n3. 选择源`nrm use xbb`\n4. 添加用户到我们的源`npm adduser`，按照提示输入`username`,`password`,`email`参数\n<!-- more -->\n备注：若不使用nrm源管理工具，则每项npm命令都需要加入\n\n`--registry http://npm.xbongbong.com.cn/`\n\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221046249.png)\n\n### 二、发布npm包\n\n1. 进入到项目，例如xbb-utils，`cd ./xbb-utils`\n2. 登录刚刚注册的用户`npm login`，跟着操作\n3. 检查是否登录成功`npm whoami`，如果输出刚刚登录的用户名，说明登录成功了\n4. 发布到私有平台`npm publish`\n5. 如果发布的包有问题，撤销发布`npm unpublish`\n\ntips：~ * ^ 和无前缀的区别\n\n- ~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0\n- ^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0\n- * 这意味着安装最新版本的依赖包\n- 不写前缀——锁版本，比如1.2.3只会下载1.2.3版本代码，若没有对应版本则会下载失败\n\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221047766.png)\n\n### 三、私有平台\n\n我们可以打开浏览器输入[http://npm.xbongbong.com.cn](http://npm.xbongbong.com.cn)，查看我们刚刚发布的包。\n\n私有平台已配置上游源，淘宝源和npm官方源，所以可以放心使用，找不到的包会现在淘宝源找，没找到再去官方源找。\n\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202112221047705.png)\n\n","categories":["npm"]},{"title":"通过shell脚本自动生成vue文件","url":"/bestjarvan/2019/08/10/vue/通过shell脚本自动生成vue文件/","content":"最近在写nuxt项目时候每次新建页面都要去新建然后引入各种需要的依赖很是麻烦，所以想写一个脚本自动生成文件 省去手动新建\n现写下实现方法 给大家参考\n<!-- more -->\n>Mac下可直接运行 \n>Windows下需要安装Cygwin类软件且配置环境变量后运行\n\n#使用方法\n1. 需要修改package.json 的scrpts 加一条create 或者自定义名字 主要是为了我们在terminal中输入指令后运行对应的脚本\n\n![package.json](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171443157.png)\n\n2. 在项目根目录新建一个template文件夹放自己的模板文件\n   文件内容根据项目需要自行修改\n\n![模板](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171443159.png)\n\n3. 之后在build文件夹下新建 create.sh 脚本文件 (代码在下面)\n\n4. 之后在terminal中输入 npm run create 指令 这个指令支持 后面携带一个不必传参数作为文件名 (npm run create xxxx)  或者直接输入npm run create\n\n![效果](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171444961.gif)\n\n文件名不能重复 如果重复不会覆盖原有文件 只会输出错误\n![名称重复](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171444987.gif)\n\n5. 生成后的文件以及文件内容\n![生成后的文件](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171444727.png)\n\n#create.sh 脚本文件\n修改```COMPONENT_PATH``` 和 ```PAGE_PATH ``` 路径改变为自己真实模板路径\n运行该脚本后\n组件会在```components```文件夹下新建组件\n页面会在```pages``` 文件夹下新建页面\n```Shell\n#!/usr/bin/env sh\ncreate () {\n  if [[ $REPLY =~ ^[Yy]$ ]]\n    then\n      PATH_DIR=\"./components/$NAME\"\n    else\n      PATH_DIR=\"./pages/$NAME\"\n    fi\n\n  if [ ! -d \"$PATH_DIR\" ]\n  then\n    mkdir $PATH_DIR\n    if [[ $PATH_DIR =~ \"components\" ]]\n    then\n      CLASS_NAME=\"component-$NAME\"\n      cp $COMPONENT_PATH \"$PATH_DIR/index.vue\"\n    else\n      CLASS_NAME=\"page-$NAME\"\n      cp $PAGE_PATH \"$PATH_DIR/index.vue\"\n    fi\n    sed -i \"\" \"s/class-name/$CLASS_NAME/\" \"$PATH_DIR/index.vue\"\n    echo -e \"\\n生成完成 \\n... \\n\"\n  else\n    echo -e \"\\n已存在文件夹 \\n$PATH_DIR\"\n  fi\n}\n\nset -e\necho \"开始生成代码...\"\nCOMPONENT_PATH=\"./template/component.vue\"\nPAGE_PATH=\"./template/page.vue\"\nif [[ -n $1 ]]\nthen\n  NAME=$1\n  read -p \"请问代码 $NAME - 是否是组件 ? (y/n)\" -n 1 -r\nelse\n  echo \"未发现名称, 请输入名称？\"\n  read NAME\n  read -p \"请问代码 $NAME - 是否是组件 ? (y/n)\" -n 1 -r\nfi\n  create\n```\n\n\n##模板组件参考\n```\n<template>\n  <div class=\"class-\">\n    component\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  data() {\n    return {}\n  },\n  methods: {\n    init() {}\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n@import '@/common/scss/var.scss';\n@import '@/common/scss/mixin.scss';\n\n.class- {\n}\n</style>\n\n```\n##模板页面参考\n```\n<template>\n  <div class=\"class-\">\n    page\n  </div>\n</template>\n\n<script>\nimport { baseMixin } from '@/common/mixins/index'\n\nexport default {\n  mixins: [baseMixin],\n  data() {\n    return {}\n  },\n  async asyncData({ $axios }) {},\n  head() {\n    return {\n      title: ''\n    }\n  },\n  mounted() {\n    this.init()\n  },\n  methods: {\n    init() {}\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n@import '@/common/scss/var.scss';\n@import '@/common/scss/mixin.scss';\n\n.class- {\n}\n</style>\n```","categories":["vue"]},{"title":"ionic2拖拽元素","url":"/bestjarvan/2018/06/20/ionic2/ionic2拖拽元素/","content":"先看效果图\n![拖拽元素](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171507697.gif)\n<!-- more -->\n1、这里用到了jq 所以第一步我们在index 中引入 两个必须的jq\n```\n  <script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.12.4.js\"></script>\n  <script type=\"text/javascript\" src=\"https://code.jquery.com/ui/1.12.1/jquery-ui.js\"></script>\n```\n\n2、第二步 我们需要在typings.d.ts中声明 $ 和 jQuery 这样才能在ts中使用这个方法\n```\ndeclare var $: any;\ndeclare var jQuery: any;\n```\n\n3、接着我们需要 引入 touchPunch.ts 这个文件 这是jq的触摸插件 jq封装好的可以直接用 ，下载之后放到某个文件夹下\n下载地址：https://gitee.com/bestjarvan/public/blob/master/mini-program-components/drag/touchPunch.ts\n\n4、放好后 我们引入app.module.ts 中 在providers中声明\n```\nproviders:[\n    TouchPunchProvider\n]\n```\n\n5、在html元素中 给需要拖拽的元素一个id 之后在ts中初始化一下我们的jq插件 就可以了\n```\n// 参考\n// html\n<ion-fab style=\"width: 5rem;height: 5rem;\" middle right #barrage id=\"barrage\">\n  <div ion-fab style=\"display: none\"></div>\n  <img src=\"./assets/images/picdetail_service.png\">\n</ion-fab>\n\n//ts\nconstructor(public touchIt:TouchPunchProvider){}\n\nionViewDidLoad() {\n  this.touchIt.init();\n  $('#barrage').draggable();\n}\n```\n完结","categories":["ionic2"]},{"title":"星星评价小程序、网页通用","url":"/bestjarvan/2018/06/14/wechat/星星评价小程序、网页通用/","content":"先看效果图\n![效果图](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171507056.gif)\n<!-- more -->\n原理是需要两张图片 一张选中的黄色，一张未选中的灰色\n![选中](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171508974.png)\n\n![未选中](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171508245.png)\n\n1、循环image标签五次\n2、绑定点击事件\n3、获取点击下标，并赋值给score变量 \n4、三目运算判断score变量于index 的关系 动态更改图片路径\n5、此方法网页也可用 通用\n```\n//wxml\n<image class=\"start\" \n        wx:for=\"{{5}}\" \n        data-index=\"{{index}}\"\n        bindtap='selectIndexNum' \n        src=\"{{score >= index ? '/utils/img/big_star_s@3x.png' : '/utils/img/big_star_n@3x.png'}}\"\n/>\n\n//普通版本 js\nselectIndexNum(e){\n  this.setData({\n    score: +e.currentTarget.dataset.index\n  })\n},\n```\n或者增强版效果\n```\n//点两次相同分数取消选择 js\nselectIndexNum(e){\n  const i = +e.currentTarget.dataset.index;\n  this.setData({\n    score: i === this.data.score ? -1 : i\n  })\n},\n```","categories":["wechat"]},{"title":"记录下小程序项目中的一些问题","url":"/bestjarvan/2018/06/08/wechat/记录下小程序项目中的一些问题/","content":"项目中遇到一些问题，不定期更新，多字预警。\n\n1、富文本展示   text有一个decode可以解析textarea中的换行符 等符号 实现简单富文本展示 并且层级不会在最高级、可控制\n![image.png](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171420624.png)\n<!-- more -->\n2、wx.setStorageSync 微信同步保存缓存 调用过多可能会报错 本地保存10MB以内 如果数据过大  在少数手机上会保存超时 解决办法 过大的数据不保存在本地 用的时候直接获取网络请求或者本地请求 (项目中遇到一个两年前的华为手机，数据量较大时会超时报错) 使用sync推荐trycatch包裹、实际项目中某些手机会报错 推荐用异步方法 wx.setStorage({})\n\n3、关于页面数据交互 两种解决办法\n>一种是使用内置方法getCurrentPage获取小程序路由堆栈[^router]获取到需要操作的路由页操作对应的方法变量等，缺点就是一单夸多个路由或复杂场景无法维护代码可读性，推荐第二种\n\n>第二种方法使用订阅发布者模式、新建一个js用于处理发布订阅逻辑或者使用npm[^publish]\n\n4、小程序网络请求可以封装在外部文件里 使用promise二次封装 提高开发效率、代码可读性，亦可统一处理header、request和response\n\n5、setData({}) 方法是异步的  同一方法内尽量少调用 会冲突导致某个setdata方法没执行 切回导致元素重绘消耗性能 解决办法 尽量调用一次 越少越好\n\n6、如果webview操作需要刷新自身的话 可以url后面加时间戳 防止因浏览器缓存没有刷新\n\n7、小程序无法动态更改tabs  所有的tabs都是在app.json中配置好的 切最多支持五个 如果小程序要实现类似用户和管理者同时打开一个小程序而展示不同的页面信息的话 有两种方案 \n\n    一种是 自制假的tabs 注入到需要用到的页面 体验不如原生完美有瑕疵\n    \n    第二种 建立一个index入口页面 在入口文件中进行权限的逻辑判断 设置一个变量保存在本地 之后进入首页后进行判断 在onload中设置需要展示的tab名字图标等信息\n```\nwx.setTabBarItem({\n    index: 0, //下标改变的\n    text: \"tab名字\",\n    iconPath: \"/utils/icon/未选中\",\n    selectedIconPath: \"/utils/icon/选择\"\n});\n```\n\n8、手机端和电脑端 通过获取时间戳的方法得到结果不一样  电脑端得到时间正常 手机端 获取时间戳 为了兼容iOS 需要写成 \"2018-06-01T00:00:00\"这种完整格式 得到的时间戳 需要减去8小时 才是正确的时间戳 注意月和日不足两位、保持两位 \n\nnew Date(\"2018-06-01T00:00:00\") / 1000 - 28800\n\n9、部分安卓机 图片地址不能有空格 不然会识别不出来 比如 aa bb.png 需写成aa_bb.png\n\n10、组件components可以使用微信提供的behaviors方法实现类似vue的mixins混入、页面page可以手动实现mixins，在微信Page(options)实例化page之前先处理一次options页面数据，判断有mixins就把需要注入的公共方法的所有方法打散到options里面 若有重复的进行覆盖合并\n\n11、项目如果用到第三方框架那么复杂的封装可以使用webpack、gulp等模块打包开发工具自定义开发可以更加契合自身项目的业务场景、按需引入 scss 、 npm、 图片压缩等提高开发效率、缩小代码体积毕竟小程序有主体包2m 分包总大小8m的限制\n\n12、一些特殊组件例如弹窗等可以参考vue 的函数式组件，通过小程的selectComponent方法实现插入，在需要用到的地方留一个锚点元素所有参数方法都在js使用中注入\n![image.png](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171420368.png)\n\n[^router]: 小程序路由堆栈最多只有10条 超出替换数组最前面的\n[^publish]: Vue项目中可以使用发布订阅着模式页可以使用一个空的vue实例，通过vue内置方法\\$on、\\$emit、\\$off等也可实现 原理相同","categories":["wechat"]},{"title":"微信小程序-模拟iOS列表","url":"/bestjarvan/2018/03/24/wechat/微信小程序-模拟iOS列表/","content":"最近刚写小程序 发现很多坑 不过先封装了一些简单的组件 慢慢用\n\n码云：[https://gitee.com/bestjarvan/public.git](https://gitee.com/bestjarvan/public.git)\n\n先看效果：\n<!-- more -->\n![未点击](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171509394.png)\n\n![点击效果](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171509070.png)\n\n用法：\n\n1、把组件放到小程序的根目录下 \n2、在需要用的页面json中写下下列代码，路径根据自己的真实路径修改\n```\n{\n\n  \"usingComponents\":{\n\n    \"button-list\": \"/components/button-list/button-list\"\n\n  }\n\n}\n```\n3、在页面中引用组件\n```\n//wxml\n    <button-list \n      bind:myevent=\"buttonClick\"  //绑定点击事件\n      wx:for=\"{{listArr}}\"        //如果列表多的话，可以循环展示\n      text=\"{{item.name}}\"        //显示的列表名字\n      img=\"{{item.img}}\"          //名字前的图标，若不传 默认隐藏 只显示文字\n      //hideRight=\"1\"             //hideRight 是否显示右边的>号  传任意值隐藏  \n    ></button-list> \n\n//js\n//如果使用循环\n    listArr:[\n      {\n        name:'我的会员卡',\n        img:'/utils/img/my_01@3x.png'\n      },\n      {\n        name:'联系客服',\n        img:'/utils/img/my_02@3x.png'\n      }]\n\nbuttonClick:(e) => {\n    //点击事件点击之后 e.detail.type == 传入组件的text值\n    console.log(e.detail.type);\n    switch (e.detail.type){\n      case '我的会员卡':\n        //...\n        break;\n      //....\n}\n```","categories":["wechat"]},{"title":"微信小程序-A-Z排序城市数据","url":"/bestjarvan/2018/03/24/wechat/微信小程序-A-Z排序城市数据/","content":"因为小程序项目需要城市列表选择， 之后在网上找了一些数据但是并不合适，所以从一些地图数据中搞出来了一套排序后的数据用。\n\n小程序用scroll-view 内置跳转动画 实现起来还是挺简单的；\n<!-- more -->\n![第一种](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171421692.png)\n\n循环对象展示数据  可以直接使用都是处理好的\n\n>下载地址：\n>链接: https://pan.baidu.com/s/11eU7nVAaO5RR9ksPYIpOIQ \n>密码: tnrv\n\n***\n之后用node把格式又改了一边，前端循环好循环一点 ，两种格式  都可以用\n\n![第二种](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171421368.png)\n\n好久不用node写东西，忽然还有点不适应...\n\n>下载地址：\n>链接: https://pan.baidu.com/s/1QPqoLF1UOy7zSQHBMowMLg \n>密码: hrjg\n\n***\n随手写了个原生js 的 demo ，动画没时间写将就参考下\n![demo](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171421829.gif)","categories":["wechat"]},{"title":"微信小程序-省市县三级联动组件city-picker","url":"/bestjarvan/2018/03/24/wechat/微信小程序-省市县三级联动组件city-picker/","content":"\n2018年11月6日更新\n![新版效果](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171421576.gif)\n\n## 修改：\n  1. 新增半透明mask背景\n  2. 城市数据存放本地 大小400kb+有需要可以放自己服务器或者请求高德地图api\n  3. 修改样式\n  4. 修改整体字体大小\n<!-- more -->\n码云：https://gitee.com/bestjarvan/public.git\n\n***\n2018年3月24日\n进一步封装picker-view  使用高德地图城市数据 需要联网或者自行下载到本地\n\n先看效果：\n![2.gif](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171444152.gif)\n\n\n\n用法：\n\n1、把组件放到小程序的根目录下\n2、在app.js 中 请求高德地图城市数据\n>2018年11月6日更新  可根据情况添加或者不添加城市数据请求、 默认不添加 城市数据已放在本地\n```\n//判断本地是否有数据 没有 就请求\nonLaunch:() => {\n  if (!wx.getStorageSync('citys')) {\n      wx.request({\n        url: \"http://restapi.amap.com/v3/config/district?&subdistrict=3&key=你的高德key\",\n        method: \"GET\",\n        success: function (res) {\n          console.log(res['data']['districts'][0]['districts']);\n          //  请求到数据 存在本地\n          wx.setStorageSync('citys', res['data']['districts'][0]['districts']);\n        }\n      })\n    }\n}\n```\n3、在需要用的页面json中写下下列代码，路径根据自己的真实路径修改\n```\n{\n  \"usingComponents\":{\n    \"city-picker\": \"../../../components/city-picker/city-picker\"\n  }\n}\n```\n4、在页面中引用组件\n```\n//wxml\n//绑定选中事件\n<city-picker bind:selected=\"selectCity\"></city-picker>\n\n//js\nselectCity: function(e){\n  console.log(e.detail);\n  //打印出来效果{province: \"广西壮族自治区\", city: \"北海市\", county: \"合浦县\"}\n}\n```","categories":["wechat"]},{"title":"ionic2极光推送iOS","url":"/bestjarvan/2017/08/08/ionic2/ionic2极光推送iOS/","content":"首先需要申请极光开发者账号 并且创建一个app应用，创建之后需要上传.p12格式的证书，拿到APP_KEY\n<!-- more -->\n通过 Cordova Plugins 安装，要求 Cordova CLI 5.0+：\n```\ncordova plugin add jpush-phonegap-plugin --variable APP_KEY=your_jpush_appkey\n```\n官方给的是API_KEY 我这里用APP_KEY成功了。\n\n下一步安装jpush包\n```\nnpm install ionic2-jpush --save\n```\n\n上面两个安装成功后，在config.xml中更改配置\n**注意widget 的id 要和 极光开发着账号中的Bundle ID 的值一样**\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442018.png)\n\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442487.png)\n\n\n\n![在package.json中查看配置 \"APP_KEY\"值和极光的APP_KEY一样就可以。](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442407.png)\n\n\n![之后需要在app.module.ts中providers引入](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442702.png)\n\n\n```\nimport { JPushService } from 'ionic2-jpush';\n```\n![下面就可以正常使用JPush了，在需要的页面中引入](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442923.png)\n\n\n![在constructor中构造一个JPush](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171511974.png)\n\n下面可以正常使用官方文档给的方法 \n也可以在极光上发送推送了\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442696.png)\n\n\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442938.png)\n\nps: app推送过之后会有一个角标1 打开应用后1没有消失，在xcode中发现注掉了两个方法\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171443706.png)\n\n\n","categories":["ionic2"]},{"title":"ionic2+cordova插件实现第三方登录","url":"/bestjarvan/2017/07/25/ionic2/ionic2+cordova插件实现QQ、微信、微博 第三方登录/","content":"#### 1.首先和所有的都一样，要分别到各个开放平台申请appid，添加测试账号\n\nQQ：腾讯开放平台 http://open.qq.com/\n微信：微信开放平台 https://open.weixin.qq.com/\n微博：新浪微博开放平台 http://open.weibo.com/\n<!-- more -->\n#### 2.通过cordova添加插件\nQQ:\n\n```\ncordova plugin add cordova-plugin-qqsdk --variable QQ_APP_ID=YOUR_QQ_APPID\n```\n微信:\n```\ncordova plugin add cordova-plugin-wechat  --variable wechatappid=YOUR_WECHAT_APPID\n```\n微博:\n```\ncordova plugin add cordova-plugin-weibosdk --variable WEIBO_APP_ID=YOUR_WEIBO_APPID\n```\n\n#### 3.1微博需要进一步去设置redirecturi\n在你的config.xml文件中添加\n ```<preference name=\"REDIRECTURI\" value=\"YOUR_WEIBO_REDIRECTURI\" />```\n必须要和微博开放平台里面的OAuth2.0 授权设置的一样\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442895.png)\n\n#### 3.2 QQ需要装@ionic-native/qqsdk\n\n```\nnpm install @ionic-native/qqsdk --save\n```\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442379.png)\n\n#### 3.3 微信、微博需要在编译文件中声明变量\n\n```\ndeclare var Wechat:any;\ndeclare var WeiboSDK:any;\n```\n之后就能在需要的地方直接使用Wechat.XXX 或者 WeiboSDK.XXX方法\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442089.png)\n\n#### 4.第三方登录代码\n\n  #####   4.1 QQ第三方登录:\n需要引入QQSDK模块\n```\nimport { QQSDK,QQShareOptions } from '@ionic-native/qqsdk';\n\nconstructor(public qq:QQSDK);\n\nQQLogin(){\n    const loginOptions: QQShareOptions = {\n      client: this.qq.ClientType.QQ,\n    };\n    this.qq.ssoLogin(loginOptions)\n      .then((result) => {\n        console.log('shareNews success');\n        alert('token is ' + result.access_token);\n        alert('userid is ' + result.userid);\n      })\n      .catch(error => {\n        console.log(error);\n      });\n}\n```\n\n##### 4.2 微信、微博第三方登录\n\n```\n  sinaLogin(){\n    WeiboSDK.ssoLogin(function (args) {\n      alert('access token is ' + args.access_token);\n      alert('userId is ' + args.userId);\n    }, function (failReason) {\n      alert(failReason);\n    });\n  }\n  wechatLogin(){\n    let scope = \"snsapi_userinfo\",\n      state = \"_\" + (+new Date());\n    Wechat.auth(scope, state, function (response) {\n      // you may use response.code to get the access token.\n      alert(JSON.stringify(response));\n    }, function (reason) {\n      alert(\"Failed: \" + reason);\n    });\n  }\n```\n**需要注意：**\n微信需要认证才能使用；\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171442953.png)\n\n微博：\n如果微博报错redirect_uri_mismatch 的话 请看3.1 设置redirecturi\n\n如果微博报错sso package or sign error 的话 需要在你的XCode里面的Info找到Bundle identifier这一项，复制粘贴到微博开放平台你的app中的 bundle id 中 保持两者值一致\n\n#### 5.分享和登录用法一致、安装好插件参考readme文档\n\n","categories":["ionic2"]},{"title":"node.js实现简单的登录注册页面","url":"/bestjarvan/2017/07/25/node/node.js实现简单的登录注册页面/","content":"首先需要新建四个文件\n\n一个服务器js\n一个保存数据的txt (代码会自动新建，手动新建也可)\n一个登陆、一个注册页面html\n<!-- more -->\ngitee：https://gitee.com/bestjarvan/user-register-nodejs-demo.git\n### 1.注册页面\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>register</title>\n</head>\n\n<body>\n\t<div>\n\t\t<label for=\"user\">用户名</label><input type=\"text\" id=\"user\">\n\t</div>\n\t<div>\n\t\t<label for=\"password\">密码</label><input type=\"password\" id=\"password\">\n\t</div>\n\t<div>\n\t\t<button id=\"register\">注册</button>\n\t</div>\n</body>\n<script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n<script>\n\t$(function () {\n\t\t$(\"#register\").click(function () {\n\t\t\t$.ajax({\n\t\t\t\turl: \"http://localhost:3000/register\",\n\t\t\t\ttype: \"POST\",\n\t\t\t\tdata: {\n\t\t\t\t\tusername: $(\"#user\").val(),\n\t\t\t\t\tpassword: $(\"#password\").val()\n\t\t\t\t},\n\t\t\t\tsuccess: function (res) {\n\t\t\t\t\talert(res.msg);\n\t\t\t\t\tif (res.code === 200) {\n\t\t\t\t\t\t// TODO....\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terror: function (err) {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t});\n</script>\n</html>\n```\n### 2.登录页面\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <title>login</title>\n</head>\n\n<body>\n  <div>\n    <label for=\"user\">用户名</label><input type=\"text\" id=\"user\">\n  </div>\n  <div>\n    <label for=\"password\">密码</label><input type=\"password\" id=\"password\">\n  </div>\n  <div>\n    <button id=\"login\">登录</button>\n    <button id=\"register\"><a href=\"register.html\">注册</a></button>\n  </div>\n</body>\n<script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n<script>\n  $(function () {\n    $(\"#login\").click(function () {\n      if ($(\"#user\").val().length == 0) {\n        return alert(\"请输入内容!\");\n      }\n      if ($(\"#password\").val().length == 0) {\n        return alert(\"请输入密码!\");\n      }\n\n      $.ajax({\n        url: \"http://localhost:3000/login\",\n        type: \"POST\",\n        data: {\n          username: $(\"#user\").val(),\n          password: $(\"#password\").val()\n        },\n        success: function (res) {\n          alert(res.msg)\n          if (res.code === 200) {\n            // TODO...\n          }\n        },\n        error: function (err) {\n          console.log(err);\n        }\n      })\n\n    })\n  });\n</script>\n</html>\n```\n### 3.搭建服务器\n\n```\nvar http = require(\"http\");\nvar url = require(\"url\");\nvar qs = require(\"querystring\");\nvar fs = require(\"fs\");\n\n// 读取文件\nfunction readFileFnc (cb, fail) {\n  fs.readFile(\"db.txt\", \"utf-8\", function (err, data) {\n    if (!err && data) {\n      console.log(\"文件中有数据\");\n      cb(data)\n    } else {\n      console.log(\"读取文件失败\");\n      fail()\n    }\n  })\n}\n\nfunction registerUser (user, res, arr) {\n  //根据前端发来的路由地址判断是登录还是注册页面，如果是注册页面\n  //同步写入db.txt文件\n  var userList = arr || []\n  userList.push(user)\n  fs.writeFileSync(\"db.txt\", JSON.stringify(userList), \"utf-8\");\n  sendMsg(res, '注册成功!', 200)\n}\n\nfunction sendMsg (res, msg, code = 200) {\n  res.writeHead(200, { 'Content-Type': 'application/json' })\n  res.end(JSON.stringify({code, msg}))\n}\n\nhttp.createServer(function (req, res) {\n  //设置请求头\n  res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n  if (req.method == \"POST\") {\n    //接收发来的用户名和密码\n    var result = \"\";\n    //获取前端代码发来的路由地址\n    var pathName = url.parse(req.url).pathname;\n\n    req.addListener(\"data\", function (chunk) {\n      result += chunk;\n    });\n\n    req.on(\"end\", function () {\n      var user = qs.parse(result);\n      //判断用户是否存在\n      (!user.username || !user.password) && sendMsg(res, '请输入用户名或密码', 103)\n      console.log(123123);\n      if (pathName === '/login') {\n        // 登录页\n        readFileFnc(\n          function (data) {\n            var arr = JSON.parse(data);\n            //遍历整个保存数据的数组  判断登录注册\n            if (Array.isArray(arr)) {\n              const userInfo = arr.find(obj => obj.username == user.username)\n              if (userInfo) {\n                if (userInfo.password == user.password) {\n                  sendMsg(res, '登录成功！', 200)\n                } else {\n                  sendMsg(res, '密码错误！', 101)\n                }\n              } else {\n                sendMsg(res, '该用户不存在', 102)\n              }\n            }\n          },\n          function () {\n            sendMsg(res, '该用户不存在', 102)\n          }\n        )\n      } else if (pathName === '/register') {\n        // 注册页\n        console.log('zhuce')\n        readFileFnc(\n          function (data) {\n            var arr = JSON.parse(data);\n            //遍历整个保存数据的数组  判断登录注册\n            if (Array.isArray(arr)) {\n              const userInfo = arr.find(obj => obj.username == user.username)\n              if (userInfo) {\n                sendMsg(res, '该用户已存在', 101)\n              } else {\n                registerUser(user, res, arr)\n              }\n            }\n          },\n          function () {\n            registerUser(user, res)\n          }\n        )\n      }\n    });\n  } else {\n    sendMsg(res, '请使用post请求', 105)\n  }\n}).listen(3000, function (err) {\n  if (!err) {\n    console.log(\"服务器启动成功，正在监听port3000...\");\n  }\n});\n```\n### 4.在db.txt文件中可以查看注册信息\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171411744.png)\n\n------end------","categories":["node"]},{"title":"虚拟主机个人网站发布","url":"/bestjarvan/2017/07/25/js/虚拟主机个人网站发布/","content":"1.购买域名之前先去工信部网站查看想要购买的域名后缀能否备案\nPS:域名绑定国外服务器或主机不需要备案，国内需要到工信部备案。\n<!-- more -->\n[传送门](http://www.miitbeian.gov.cn/publish/query/indexFirst.action)\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171420554.png)\n进入之后在下图域名类型名称中 输入想要购买的后缀，之后模糊查询 能查到就是可以备案 ，查询不到的 目前无法备案\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171420595.png)\n2、购买域名，自己可以去万网看，价位不等\n3、购买虚拟主机\n　　　　国内有挺多免费的虚拟主机，这里用的是一个河南某安的免费主机\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171420913.png)\n查看详情之后点击 直接购买 脚本默认PHP  可以选择ASP.NET\n最高年限可以选择五年\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171420927.png)\n到了这一步恭喜你已经有了自己第一个虚拟主机，点击管理可以查看主机的详细信息\n\n送的主机有1G的空间 并且没有访问流量是20G 如果是一般的个人小网站已经足够用了\n\n可以用ftp工具管理你的空间，所有的文件放到WEB文件夹下，个人主页默认会搜索WEB文件夹下根目录中的index文件(index.php , index.html等)\n最后绑定域名之后就可以通过自己的域名访问到自己WEB文件夹下的index文件了\n\n\n4、域名备案\n\n绑定域名之前需要把域名备案，在哪里买的空间就需要委托购买空间的公司备案\n\n因为用的景安的 所以还是在景安备案，找到景安主页导航栏上方的  网站备案  进入网站备案系统\n\n点击开始备案之后填写自己真实信息，根据个地市的不同要求 ，需要提供不同的材料，主要材料包括\n\n身份证正反面照片\n备案人在景安幕布前的照片\n个人核检单填写(核检单在备案系统首页中可以找到)\n根据当地特殊要求，若没有特地要求 前三个就可以了\n 备案时间：景安审核时间大概3天左右，之后景安会提交到工信部大概20天左右会发短息提示备案通过\n\n之后进行下一步\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171419774.png)\n\n5、 域名解析，绑定域名\n在景安个人中心找到并进入DNSPod解析\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171419716.png)\n之后点击添加域名 ----->输入域名后确认------>点击添加的域名右边的域名管理------>点击新增记录\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171419705.png)\n第一项主机记录填www \n记录类型选择　　CNAME\n记录值填写你的服务器的域名解析别名的值\nTTL默认600 不用修改\n![](https://yahuiimg.oss-cn-hangzhou.aliyuncs.com/202201171419707.png)\n下面在购买域名的地方进行域名DNS解析\n把景安的DNS填入两个确定之后48小时之内生效，快一点的大概30分钟左右\n\n一旦域名解析成功，就可以通过域名访问你的个人网站了\n\n-------end-------","categories":["js"]}]